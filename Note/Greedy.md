# 贪心算法(Greedy algorithm)

贪心算法很简单: **每步都采取最优的做法, 即每步都选择局部最优解, 最终得到的就是全局最优解**. 
用一种局部最功利的标准, 总是能做出在当前看来是最好的选择.

贪心算法并非在任何情况下都行之有效, 但是**它易于实现**.

贪心算法**用来求解最大或者最小解**.

简单贪心题目: #1431, 1403, 1221

---

## 经典贪心算法问题: 区间调度问题(Interval Scheduling)

给你很多形如`[start, end]`的闭区间, 请你设计一个算法, **算出这些区间中最多有几个互不相交的区间**.

```java
int intervalScheduling(int[][] ints) {}
```

例如: `intvs=[[1,3],[2,4],[3,6]]`, 这些区间最多有两个区间互不相交, 即`[[1,3],[3,6]]`, 你的算法应该返回`2`.

更进一步这个区间调度问题可以具体化为:

**比如你今天有好几个活动, 每个活动都可以用区间`[start,end]`表示开始和结束的时间, 请问你今天最多能参加几个活动呢?**

等待一系列问题.

### 思路

1. 从区间集合`intvs`中选择一个区间`x`, 这个`x`是在**当前所有区间中结束最早的(end 最小)**.
2. 把所有与`x`区间相交的区间从区间集合`intvs`中删除.
3. 重复步骤`1`和`2`, 直到`intvs`为空为止; 之前选出的那些`x`就是最大不相交子集.

**上述步骤中第`1`步粗体的地方是关键**, 
我们要找的不是每次选择可选区间中开始最早的那个, 因为可能存在某些区间开始很早, 但是很长, 使得我们错误地错过了一些短的区间.
也不是每次选择可选区间中最短的那个, 也不是选择出现冲突最少的那个区间, 这些方案都能很容易举出反例, 不是正确的方案.

### 实现

```java
class Greedy {
    int intervalSchedule(int [][] intvs) {
        // 将 intvs 中每个区间按照 end 大小排序
        Arrays.sort(intvs, (int [] a, int []b) -> {
            return a[1] - b[1];
        });
        // 至少有一个区间不相交
        int count = 1;
        // 排序后, 第一个区间就是 x
        int x_end = intvs[0][1];
        // 遍历全部区间
        for (int [] interval : intvs) {
            int start = interval[0];
            // 寻找与 x 不相交的区间, 即寻找开始位置 start 大于 x_end 的区间.
            if (start >= x_end) {
                count++;
                x_end = interval[1]; // 更新 x_end.
            }
        }
        return count;
    }   
}
```

题目: #435, 452

---

## 跳跃游戏 (Jump Game)

### 题目一 leetcode #55:

> 给定一个非负整数数组`nums`, 你最初位于数组的**第一个下标**;
> 数组中的每个元素代表你在该位置可以跳跃的最大长度;
>
> 判断你是否能够到达最后一个下标。

- 示例:

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

- 思路:

每一步都计算一下从当前位置最远能够跳到哪里, 
然后和一个全局最优的最远位置`farthest`做对比, 
通过每一步的最优解, 更新全局最优解, 这就是贪心.

```
jump length:   2, 3, 1, 1, 4
step:          0, 1, 2, 3, 4
farthest:      2, 4, 3, 4, 8
```

这里需要保证 `farthest` **严格大于** `step`.

- 实现:

```java
class Greedy{
      public boolean canJump(int[] nums) {
          final int N = nums.length;
          int farthest = 0;
          for (int step = 0; step < N - 1; step++) {
              farthest = Math.max(farthest, step + nums[step]);
              if (farthest <= step) return false;`
          }
          return farthest >= (N - 1);
      }
}
```

### 题目二 leetcode #45:

> 给定一个非负整数数组，你最初位于数组的第一个位置。
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
> 假设你总是可以到达数组的最后一个位置。

问题变为: **保证你一定可以跳到最后一格, 请问你最少要跳多少次, 才能跳过去?**

- 示例:

```
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2.
      从下标为 0 跳到下标为 1 的位置, 跳 1 步, 然后跳 3 步到达数组的最后一个位置.
```

- 思路:

我们可以贪心地进行正向查找, **每次找到可到达的最远位置, 就可以在线性时间内得到最少的跳跃次数**.

```
距离:  2, 3, 1, 1, 4, 2, 3
位置:  0, 1, 2, 3, 4, 5, 6
----
从位置 0 出发, 最远可达位置 2; 
在位置 0 可达的位置中, 位置 1 的值为 3; 
从位置 1 出发可达更远的位置, 因此第一步选择到达位置 1. 
----
从位置 1 出发, 最远可达位置 4; 
在位置 1 可达的位置中, 位置 4 的值为 4; 
从位置 4 出发可达更远的位置, 因此第二步到达位置 4.
--- 
以此类推, 第三步选择位置 6;
所以最少跳跃次数为 3 次.
```

- 实现:

```java
class Greedy{
      public boolean jump(int[] nums) {
          final int N = nums.length;
          int end = 0, farthest = 0;
          int jumps = 0;
          for (int step = 0; step < N - 1; step++) {
              farthest = Math.max(farthest, step + nums[step]);
              if (end == i) {
                  jumps++;
                  end = farthest;
              }
          }
          return jumps;
      }
}
```