# 贪心算法(Greedy algorithm)

贪心算法很简单: **每步都采取最优的做法, 即每步都选择局部最优解, 最终得到的就是全局最优解**. 
用一种局部最功利的标准, 总是能做出在当前看来是最好的选择.

贪心算法并非在任何情况下都行之有效, 但是**它易于实现**.

贪心算法**用来求解最大或者最小解**.

简单贪心题目: #1431, 1403, 1221

---

## 经典贪心算法问题: 区间调度问题(Interval Scheduling)

给你很多形如`[start, end]`的闭区间, 请你设计一个算法, **算出这些区间中最多有几个互不相交的区间**.

```java
int intervalScheduling(int[][] ints) {}
```

例如: `intvs=[[1,3],[2,4],[3,6]]`, 这些区间最多有两个区间互不相交, 即`[[1,3],[3,6]]`, 你的算法应该返回`2`.

更进一步这个区间调度问题可以具体化为:

**比如你今天有好几个活动, 每个活动都可以用区间`[start,end]`表示开始和结束的时间, 请问你今天最多能参加几个活动呢?**

等待一系列问题.

### 思路

1. 从区间集合`intvs`中选择一个区间`x`, 这个`x`是在**当前所有区间中结束最早的(end 最小)**.
2. 把所有与`x`区间相交的区间从区间集合`intvs`中删除.
3. 重复步骤`1`和`2`, 直到`intvs`为空为止; 之前选出的那些`x`就是最大不相交子集.

**上述步骤中第`1`步粗体的地方是关键**, 
我们要找的不是每次选择可选区间中开始最早的那个, 因为可能存在某些区间开始很早, 但是很长, 使得我们错误地错过了一些短的区间.
也不是每次选择可选区间中最短的那个, 也不是选择出现冲突最少的那个区间, 这些方案都能很容易举出反例, 不是正确的方案.

### 实现

```java
class Greedy {
    int intervalSchedule(int [][] intvs) {
        // 将 intvs 中每个区间按照 end 大小排序
        Arrays.sort(intvs, (int [] a, int []b) -> {
            return a[1] - b[1];
        });
        // 至少有一个区间不相交
        int count = 1;
        // 排序后, 第一个区间就是 x
        int x_end = intvs[0][1];
        // 遍历全部区间
        for (int [] interval : intvs) {
            int start = interval[0];
            // 寻找与 x 不相交的区间, 即寻找开始位置 start 大于 x_end 的区间.
            if (start >= x_end) {
                count++;
                x_end = interval[1]; // 更新 x_end.
            }
        }
        return count;
    }   
}
```

题目: #435, 452

---