# 贪心算法(Greedy algorithm)

贪心算法很简单: **每步都采取最优的做法, 即每步都选择局部最优解, 最终得到的就是全局最优解**. 
用一种局部最功利的标准, 总是能做出在当前看来是最好的选择.

贪心算法并非在任何情况下都行之有效, 但是**它易于实现**.

贪心算法**用来求解最大或者最小解**.

简单贪心题目: #1431, 1403, 1221, 12

---

## 经典贪心算法问题: 区间调度问题(Interval Scheduling)

给你很多形如`[start, end]`的闭区间, 请你设计一个算法, **算出这些区间中最多有几个互不相交的区间**.

```java
int intervalScheduling(int[][] ints) {}
```

例如: `intvs=[[1,3],[2,4],[3,6]]`, 这些区间最多有两个区间互不相交, 即`[[1,3],[3,6]]`, 你的算法应该返回`2`.

更进一步这个区间调度问题可以具体化为:

**比如你今天有好几个活动, 每个活动都可以用区间`[start,end]`表示开始和结束的时间, 请问你今天最多能参加几个活动呢?**

等待一系列问题.

### 思路

1. 从区间集合`intvs`中选择一个区间`x`, 这个`x`是在**当前所有区间中结束最早的(end 最小)**.
2. 把所有与`x`区间相交的区间从区间集合`intvs`中删除.
3. 重复步骤`1`和`2`, 直到`intvs`为空为止; 之前选出的那些`x`就是最大不相交子集.

**上述步骤中第`1`步粗体的地方是关键**, 
我们要找的不是每次选择可选区间中开始最早的那个, 因为可能存在某些区间开始很早, 但是很长, 使得我们错误地错过了一些短的区间.
也不是每次选择可选区间中最短的那个, 也不是选择出现冲突最少的那个区间, 这些方案都能很容易举出反例, 不是正确的方案.

### 实现

```java
class Greedy {
    int intervalSchedule(int [][] intvs) {
        // 将 intvs 中每个区间按照 end 大小排序
        Arrays.sort(intvs, (int [] a, int []b) -> {
            return a[1] - b[1];
        });
        // 至少有一个区间不相交
        int count = 1;
        // 排序后, 第一个区间就是 x
        int x_end = intvs[0][1];
        // 遍历全部区间
        for (int [] interval : intvs) {
            int start = interval[0];
            // 寻找与 x 不相交的区间, 即寻找开始位置 start 大于 x_end 的区间.
            if (start >= x_end) {
                count++;
                x_end = interval[1]; // 更新 x_end.
            }
        }
        return count;
    }   
}
```

题目: #435, 452

### 延伸: 区间问题

**区间问题肯定按照区间的起点或者终点进行排序**.

因为排序之后更容易找到相邻区间之间的联系, 如果是求最值的问题, 可以使用贪心算法进行求解.

至于到底如何排序, 这个就要因题而异了.

#### 题目: leetcode #1024 视频拼接

> 你将会获得一系列视频片段, 这些片段来自于一项持续时长为`T`秒的体育赛事。这些片段可能有所重叠, 也可能长度不一。
>
> 视频片段`clips[i]`都用区间进行表示: 开始于`clips[i][0]`并于`clips[i][1]`结束。
> 我们甚至可以对这些片段自由地再剪辑, 例如片段`[0, 7]`可以剪切成`[0, 1] + [1, 3] + [3, 7]`三部分。
>
> 我们需要将这些片段进行再剪辑, 并将剪辑后的内容拼接成覆盖整个运动过程的片段(`[0, T]`)。

- 示例:

```
输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
输出：3
解释：
    我们选中 [0,2], [8,10], [1,9] 这三个片段。
    然后，按下面的方案重制比赛片段：
    将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。
    现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。
```

- 思路: 

1. 若要用若干片段拼凑成完成视频`[0, T]`, 至少又一个片段起点是`0`.
2. 如果若干片段起点相同, 选择时长 **最长的(即终点最大的)** 的视频 (贪心).

```
                                |
（选择）clips[0]  |______________|
       clips[1]  |________|     |
       clips[2]        |_____|  |
（选择）clips[3]           |_____|__________|
       clips[4]                 |_____|
       clips[5]                 |  |___________|
                                |
```
> 如果`clips[0]`是的起点是`0`, 那么`clips[0]`这个视频一定会被选择.
>
> 我们会比较所有起点小于`clips[0][1]`的区间, 根据贪心策略, 它们中**终点最大的那个区间**就是第二个会被选中的视频.

---

## 跳跃游戏 (Jump Game)

### 题目一 leetcode #55:

> 给定一个非负整数数组`nums`, 你最初位于数组的**第一个下标**;
> 数组中的每个元素代表你在该位置可以跳跃的最大长度;
>
> 判断你是否能够到达最后一个下标。

- 示例:

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

- 思路:

每一步都计算一下从当前位置最远能够跳到哪里, 
然后和一个全局最优的最远位置`farthest`做对比, 
通过每一步的最优解, 更新全局最优解, 这就是贪心.

```
jump length:   2, 3, 1, 1, 4
step:          0, 1, 2, 3, 4
farthest:      2, 4, 3, 4, -
```

这里需要保证 `farthest` **严格大于** `step`.

- 实现:

```java
class Greedy{
      public boolean canJump(int[] nums) {
          final int N = nums.length;
          int farthest = 0;
          for (int step = 0; step < N - 1; step++) {
              farthest = Math.max(farthest, step + nums[step]);
              if (farthest <= step) return false;
          }
          return farthest >= (N - 1);
      }
}
```

### 题目二 leetcode #45:

> 给定一个非负整数数组，你最初位于数组的第一个位置。
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
> 假设你总是可以到达数组的最后一个位置。

问题变为: **保证你一定可以跳到最后一格, 请问你最少要跳多少次, 才能跳过去?**

- 示例:

```
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2.
      从下标为 0 跳到下标为 1 的位置, 跳 1 步, 然后跳 3 步到达数组的最后一个位置.
```

- 思路:

我们可以贪心地进行正向查找, **每次找到可到达的最远位置, 就可以在线性时间内得到最少的跳跃次数**.

```
距离:  2, 3, 1, 1, 4, 2, 3
位置:  0, 1, 2, 3, 4, 5, 6
----
从位置 0 出发, 最远可达位置 2; 
在位置 0 可达的位置中, 位置 1 的值为 3; 
从位置 1 出发可达更远的位置, 因此第一步选择到达位置 1. 
----
从位置 1 出发, 最远可达位置 4; 
在位置 1 可达的位置中, 位置 4 的值为 4; 
从位置 4 出发可达更远的位置, 因此第二步到达位置 4.
--- 
以此类推, 第三步选择位置 6;
所以最少跳跃次数为 3 次.
```

- 实现:

```java
class Greedy{
      public boolean jump(int[] nums) {
          final int N = nums.length;
          int end = 0, farthest = 0;
          int jumps = 0;
          for (int step = 0; step < N - 1; step++) {
              farthest = Math.max(farthest, step + nums[step]);
              if (end == i) {
                  jumps++;
                  end = farthest;
              }
          }
          return jumps;
      }
}
```