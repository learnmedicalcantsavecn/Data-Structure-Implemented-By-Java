# 二叉树 - Binary Tree

**递归算法的关键要明确函数的定义, 相信这个定义, 而不要跳进递归细节**.

写二叉树的算法题, 都是基于递归框架的, 
我们先要搞清楚 root 节点它自己要做什么,
然后根据题目要求选择使用前序、中序、后续的递归框架.

```java
/* 二叉树遍历框架 */
void traverse(Node root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
```

二叉树题目的难点在于如何通过题目的要求思考出每一个节点需要做什么, 这个只能通过多刷题进行练习了.

**快速排序就是个二叉树的前序遍历, 归并排序就是个二叉树的后序遍历**.

---

### 翻转二叉树

```
     4               4
   /   \            /  \
  2     7      ->  7    2
 / \   / \        / \  / \
1   3 6   9      6   9 1  3
```

我们发现只要把二叉树上的每一个节点的左右子节点进行交换, 最后的结果就是完全翻转之后的二叉树.

题目: #226

---

### 填充二叉树节点的右侧指针

**二叉树题目的一个难点就是, 如何把题目的要求细化成每个节点需要做的事情**.

如果解决该问题时仅使用一个节点, 将每个节点的左右子节点都穿起来, 其实并不能解决问题: 
考虑两个节点可能没有共同的父节点.

思路: 我们使用两个节点, 分别为root的左子树和右子树
1. 先将这两个节点相连接;
2. 连接父节点相同的两个子节点(分别对root.left和root.right进行这一步)
3. 连接跨越父节点的两个子节点

题目: #116

---

### 将二叉树展开为链表

1. 将 root 的左子树和右子树拉平.
2. 将 root 的右子树接到左子树下方, 然后将整个左子树作为右子树.

```
     1               1             1         
   /   \            /  \            \
  2     5     ->   2    5    ->      2    
 / \     \          \    \            \
3   4     6          3    6            3
                      \                 \
                       4                 4
                                          \
                                           5
                                            \
                                             6
```

题目: #114

---

### 构造最大二叉树

**对于构造二叉树的问题, 根节点要做的就是把想办法把自己构造出来**.

思路: 对于每个根节点, 只需要找到当前nums中的最大值和对应的索引, 然后递归调用左右数组构造左右子树即可.

题目: #654

---

### 通过前序和中序遍历结果构造二叉树

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

对于前序遍历结果, 第一个元素`3`为二叉树的根节点.

**如何确定前序遍历左右子树是关键**.

对于中序遍历结果, 已知根节点, 便可以用根节点在中序遍历中的索引`ind`,
将中序遍历结果分为左右子树.

```     
            ind
             |
inorder = [9,3,15,20,7]
           |         |
        inStart    inEnd
```

左子树区间为`[inStart, ind]`, 右子树区间为`[ind+1, inEnd]`.

根据中序遍历中根节点索引`ind`以及起始点所以`inStart`.

得到前序遍历左子树区间`[preStart+1, preStart + leftSize]`
得到前序遍历右子树区间`[preStart + leftSize + 1, preEnd]`

```        
         preStart(root)
            |
preorder = [3,9,20,15,7]
                |
       preStart + leftSize +1
```

题目: #105

---

### 寻找重复子树

对于这样一棵二叉树

```
        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4
```

它有两颗重复的子树:

```
      2
     /     
    4
```

和

```
   4
```

对于某一个节点来说, 它需要做两件事:

1. 首先要知道以自己为根节点的树长什么样
2. 以其他节点为根的树长什么样

解决思路:

1. 通过二叉树的后序遍历很容易知道以自己为根节点的树长什么样

```java
String traverse(TreeNode root) {
    // 对于空节点，可以用一个特殊字符表示
    if (root == null) {
        return "#";
    }
    // 将左右子树序列化成字符串
    String left = traverse(root.left);
    String right = traverse(root.right);
    /* 后序遍历代码位置 */
    // 左右子树加上自己，就是以自己为根的二叉树序列化结果
    String subTree = left + "," + right + "," + root.val;
    return subTree;
}
```

2. 借助一个数据结构(HashMap)存储所有节点的子树, 判断有无重复即可

题目: #652

---

# 二分搜索树 - Binary Search Tree

1. 对于 BST 的每一个节点node, 左子树节点的值都比node的值要小, 右子树节点的值都比node的值大.

2. 对于 BST 的每一个节点node, 它的左侧子树和右侧子树都是BST.

**BST的中序遍历结果是有序的(升序)**.

```java
void traverse(TreeNode root) {
    if (root == null) return;
    traverse(root.left);
    // 中序遍历代码位置
    print(root.val);
    traverse(root.right);
}
```

### 寻找第K小第元素

解法一: 由于我们已知BST中序遍历结果是有序的, 所有通过中序遍历可以找到第k小第元素.

解法二: 用栈模拟递归解法

题目: #230